open Srk
open OUnit
open BatPervasives
open Test_pervasives

module V = Linear.QQVector

let mk_vector l = mk_vector (List.rev l)

let xy_lattice =
  IntLattice.hermitize (List.map mk_vector [[0 ; 1] ; [1 ; 0]])

let empty_lattice = IntLattice.hermitize []

let lattice1 =
  (*
     [ 2 ; 4 ; 4 ; 5
       1 ; 2 ; 3 ; 4
       3 ; 6 ; 2 ; 1 ]
  -> [ 1 ; 2 ; 3 ; 4
       2 ; 4 ; 4 ; 5
       3 ; 6 ; 2 ; 1 ]
  -> [ 1 ; 2 ;  3 ;  4
       0 ; 0 ; -2 ; -3
       0 ; 0 ; -7 ; -11 ]
  -> [ 1 ; 2 ; 3 ; 4
       0 ; 0 ; 2 ; 3
       0 ; 0 ; 7 ; 11 ]
  -> [ 1 ; 2 ; 3 ; 4
       0 ; 0 ; 2 ; 3
       0 ; 0 ; 1 ; 2 ]
  -> [ 1 ; 2 ; 3 ; 4
       0 ; 0 ; 1 ; 2
       0 ; 0 ; 2 ; 3 ]
  -> [ 1 ; 2 ; 0 ; -2
       0 ; 0 ; 1 ;  2
       0 ; 0 ; 0 ; -1 ]
  -> [ 1 ; 2 ; 0 ; -2
       0 ; 0 ; 1 ;  2
       0 ; 0 ; 0 ;  1 ]
  -> [ 1 ; 2 ; 0 ; 0
       0 ; 0 ; 1 ; 0
       0 ; 0 ; 0 ; 1 ]
   *)
  let v1 = mk_vector [2 ; 4 ; 4 ; 5] in
  let v2 = mk_vector [1 ; 2 ; 3 ; 4] in
  let v3 = mk_vector [3 ; 6 ; 2 ; 1] in
  IntLattice.hermitize [v1 ; v2 ; v3]

let lattice2 =
  (*
     [ 2 ; 1 ; 0 ; 0
       0 ; 1 ; 2 ; 0
     ]
  -> [ 2 ; 0 ; -2 ; 0
       0 ; 1 ;  2 ; 0
     ]
   *)
  let v1 = mk_vector [2 ; 1 ; 0 ; 0] in
  let v2 = mk_vector [0 ; 1 ; 2 ; 0] in
  IntLattice.hermitize [v1 ; v2]

let proj_1_01 =
  IntLattice.project_lower 1 lattice1

let proj_2_0 =
  IntLattice.project_lower 0 lattice2

let sum_projected_12_in_23 =
  (* [ 2 ; 1 ] ; [ 1 ; 2 ] --> [ 1 ; 2 ] ; [ 0 ; -3 ] *)
  let proj_1_23 = IntLattice.project (fun dim -> 2 <= dim && dim <= 3) lattice1 in
  let proj_2_23 = IntLattice.project (fun dim -> 2 <= dim && dim <= 3) lattice2 in
  IntLattice.sum proj_1_23 proj_2_23

let test_hnf () =
  let basis1 = IntLattice.basis lattice1 in
  let expected_basis1 = [ [1 ; 2 ; 0 ; 0] ; [0 ; 0 ; 1 ; 0] ; [0 ; 0 ; 0 ; 1] ]
                        |> List.map mk_vector in
  let basis2 = IntLattice.basis lattice2 in
  let expected_basis2 = [ [2 ; 0 ; -2 ; 0] ; [0 ; 1 ; 2 ; 0] ]
                        |> List.map mk_vector in
  List.iter2 assert_equal_qqvector basis1 expected_basis1;
  List.iter2 assert_equal_qqvector basis2 expected_basis2

let test_member () =
  let v1 = mk_vector [ 2 ; 4 ; 6 ; 0] in
  let v2 = mk_vector [ 2 ; 1 ; 0 ; 0] in
  assert_equal (IntLattice.member v1 lattice1) true;
  assert_equal (IntLattice.member v1 lattice2) true;
  assert_equal (IntLattice.member v2 lattice1) false;
  assert_equal (IntLattice.member v2 lattice2) true

let test_project () =
  let proj_1_2 = IntLattice.project (fun dim -> dim = 2) lattice1 in
  assert_equal (IntLattice.subset proj_2_0 empty_lattice) true;
  assert_equal (IntLattice.subset proj_1_01 xy_lattice) true;
  assert_equal (IntLattice.subset proj_1_2 empty_lattice) true;
  assert_equal (IntLattice.subset proj_1_2 empty_lattice) true;
  let proj_2_23 = IntLattice.project (fun dim -> 2 <= dim && dim <= 3) lattice2 in
  let proj_2_23' = IntLattice.hermitize [mk_vector [2 ; 1; 0 ; 0]] in
  assert_equal (IntLattice.subset proj_2_23 proj_2_23') true;
  assert_equal (IntLattice.subset proj_2_23' proj_2_23) true

let test_intersect () =
  (* [ 1 ; 2 ; 0 ; 0
       0 ; 0 ; 1 ; 0
       0 ; 0 ; 0 ; 1 ]
     intersect with
     [ 2 ; 0 ; -2 ; 0
       0 ; 1 ;  2 ; 0
     ]

     [ 1 ;  2 ;  0 ; 0 ; 0 ; 0 ;  0 ; 0
       0 ;  0 ;  1 ; 0 ; 0 ; 0 ;  0 ; 0
       0 ;  0 ;  0 ; 1 ; 0 ; 0 ;  0 ; 0
      -2 ;  0 ;  2 ; 0 ; 2 ; 0 ; -2 ; 0
       0 ; -1 ; -2 ; 0 ; 0 ; 1 ;  2 ; 0
     ]
     ->
     [ 1 ;  2 ;  0 ; 0 ; 0 ; 0 ;  0 ; 0
       0 ;  0 ;  1 ; 0 ; 0 ; 0 ;  0 ; 0
       0 ;  0 ;  0 ; 1 ; 0 ; 0 ;  0 ; 0
       0 ;  4 ;  2 ; 0 ; 2 ; 0 ; -2 ; 0
       0 ; -1 ; -2 ; 0 ; 0 ; 1 ;  2 ; 0
     ]
     ->
     [ 1 ; 2 ; 0 ; 0 ; 0 ;  0 ;  0 ; 0
       0 ; 0 ; 1 ; 0 ; 0 ;  0 ;  0 ; 0
       0 ; 0 ; 0 ; 1 ; 0 ;  0 ;  0 ; 0
       0 ; 4 ; 2 ; 0 ; 2 ;  0 ; -2 ; 0
       0 ; 1 ; 2 ; 0 ; 0 ; -1 ; -2 ; 0
     ]
     ->
     [ 1 ; 2 ; 0 ; 0 ; 0 ;  0 ;  0 ; 0
       0 ; 1 ; 2 ; 0 ; 0 ; -1 ; -2 ; 0
       0 ; 0 ; 0 ; 1 ; 0 ;  0 ;  0 ; 0
       0 ; 4 ; 2 ; 0 ; 2 ;  0 ; -2 ; 0
       0 ; 0 ; 1 ; 0 ; 0 ;  0 ;  0 ; 0
     ]
     ->
     [ 1 ; 2 ;  0 ; 0 ; 0 ;  0 ;  0 ; 0
       0 ; 1 ;  2 ; 0 ; 0 ; -1 ; -2 ; 0
       0 ; 0 ;  0 ; 1 ; 0 ;  0 ;  0 ; 0
       0 ; 0 ; -6 ; 0 ; 2 ;  4 ;  6 ; 0
       0 ; 0 ;  1 ; 0 ; 0 ;  0 ;  0 ; 0
     ]
     ->
     [ 1 ; 2 ;  0 ; 0 ; 0 ;  0 ;  0 ; 0
       0 ; 1 ;  2 ; 0 ; 0 ; -1 ; -2 ; 0
       0 ; 0 ;  0 ; 1 ; 0 ;  0 ;  0 ; 0
       0 ; 0 ;  1 ; 0 ; 0 ;  0 ;  0 ; 0
       0 ; 0 ;  0 ; 0 ; 2 ;  4 ;  6 ; 0
     ]
     Hence, the intersection is generated by [2 ; 4 ; 6 ; 0].
   *)
  let intersection = IntLattice.intersect lattice1 lattice2 in
  let expected = IntLattice.hermitize [mk_vector [2 ; 4 ; 6 ; 0]] in
  assert_equal (IntLattice.subset intersection expected) true;
  assert_equal (IntLattice.subset expected intersection) true

let test_sum () =
  let lat1 = IntLattice.hermitize [mk_vector [1 ; 2]] in
  let lat2 = IntLattice.hermitize [mk_vector [-2 ; -5]] in
  let sum = IntLattice.sum lat1 lat2 in
  assert_equal (IntLattice.subset sum xy_lattice) true;
  assert_equal (IntLattice.subset xy_lattice sum) true

let suite = "IntLattice" >::: [
      "test_hnf" >:: test_hnf
    ; "test_member" >:: test_member
    ; "test_project" >:: test_project
    ; "test_intersect" >:: test_intersect
    ; "test_sum" >:: test_sum
    ]
