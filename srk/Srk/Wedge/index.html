<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Wedge (srk.Srk.Wedge)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">srk</a> &#x00BB; <a href="../index.html">Srk</a> &#x00BB; Wedge</nav><h1>Module <code>Srk.Wedge</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-show"><a href="#val-show" class="anchor"></a><code><span class="keyword">val</span> show : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <span>?&#8288;lemma:<span>(<span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-meet"><a href="#val-meet" class="anchor"></a><code><span class="keyword">val</span> meet : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-meet_atoms"><a href="#val-meet_atoms" class="anchor"></a><code><span class="keyword">val</span> meet_atoms : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-widen"><a href="#val-widen" class="anchor"></a><code><span class="keyword">val</span> widen : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-of_atoms"><a href="#val-of_atoms" class="anchor"></a><code><span class="keyword">val</span> of_atoms : <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-to_atoms"><a href="#val-to_atoms" class="anchor"></a><code><span class="keyword">val</span> to_atoms : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> list</span></code></dt><dt class="spec value" id="val-to_formula"><a href="#val-to_formula" class="anchor"></a><code><span class="keyword">val</span> to_formula : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span></code></dt><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : <span>?&#8288;lemma:<span>(<span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;subterm:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Project symbols out of a wedge that do not satisfy the given predicate. Additionally project out terms that contain a symbol that does not satisfy the subterm predicate.</p></dd></dl><dl><dt class="spec value" id="val-top"><a href="#val-top" class="anchor"></a><code><span class="keyword">val</span> top : <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-bottom"><a href="#val-bottom" class="anchor"></a><code><span class="keyword">val</span> bottom : <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-is_bottom"><a href="#val-is_bottom" class="anchor"></a><code><span class="keyword">val</span> is_bottom : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_top"><a href="#val-is_top" class="anchor"></a><code><span class="keyword">val</span> is_top : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-farkas_equalities"><a href="#val-farkas_equalities" class="anchor"></a><code><span class="keyword">val</span> farkas_equalities : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-term">Syntax.term</a></span> * <a href="../Linear/QQVector/index.html#type-t">Linear.QQVector.t</a>)</span> list</span></code></dt><dd><p>Compute a representation of the set of equalities that are entailed by a given wedge as a list <code>(term0, vector0),...,(termn,vectorn)</code>. The interpretation of this representation is that for any vector v, <code>wedge |= (vector0 . v) term0 + ... + (vectorn . v) termn = 0</code> where <code>.</code> represents the dot product.</p></dd></dl><dl><dt class="spec value" id="val-symbolic_bounds"><a href="#val-symbolic_bounds" class="anchor"></a><code><span class="keyword">val</span> symbolic_bounds : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-term">Syntax.term</a></span> list</span> * <span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-term">Syntax.term</a></span> list</span></code></dt><dd><p>Given a wedge <code>wedge</code> and a symbol <code>symbol</code>, compute a list of lower bounds and upper bounds for <code>symbol</code> that are implied by <code>wedge</code>.</p></dd></dl><dl><dt class="spec value" id="val-bounds"><a href="#val-bounds" class="anchor"></a><code><span class="keyword">val</span> bounds : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-term">Syntax.term</a></span> <span>&#45;&gt;</span> <a href="../Interval/index.html#type-t">Interval.t</a></code></dt><dd><p>Given a wedge <code>wedge</code> and a term <code>term</code>, compute a lower and upper bounds for <code>term</code> within the region <code>wedge</code>.</p></dd></dl><dl><dt class="spec value" id="val-ensure_min_max"><a href="#val-ensure_min_max" class="anchor"></a><code><span class="keyword">val</span> ensure_min_max : <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Ensure that a context has named <code>max</code> and <code>min</code> symbols. If the symbols are not present in the context <code>ensure_max_min</code> registers them.</p></dd></dl><dl><dt class="spec value" id="val-abstract"><a href="#val-abstract" class="anchor"></a><code><span class="keyword">val</span> abstract : <span>?&#8288;exists:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;subterm:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Compute a wedge that over-approximates a given formula</p></dd></dl><dl><dt class="spec value" id="val-abstract_equalities"><a href="#val-abstract_equalities" class="anchor"></a><code><span class="keyword">val</span> abstract_equalities : <span>?&#8288;exists:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;subterm:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Compute a set of equations that are entailed by a given formula</p></dd></dl><dl><dt class="spec type" id="type-subwedge"><a href="#type-subwedge" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) subwedge</span></code><code> = </code><code>{</code><table class="record"><tr id="type-subwedge.of_wedge" class="anchored"><td class="def field"><a href="#type-subwedge.of_wedge" class="anchor"></a><code>of_wedge : <span>lemma:<span>(<span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span>;</code></td></tr><tr id="type-subwedge.join" class="anchored"><td class="def field"><a href="#type-subwedge.join" class="anchor"></a><code>join : <span>lemma:<span>(<span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>;</code></td></tr><tr id="type-subwedge.to_formula" class="anchored"><td class="def field"><a href="#type-subwedge.to_formula" class="anchor"></a><code>to_formula : <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span>;</code></td></tr></table><code>}</code></dt><dd><p>A subwedge is an abstract domain that can be associated with a sublattice of the disjunctive completion of the lattice of wedges (see <code>abstract_subwedge</code>). The <code>of_wedge</code> and <code>join</code> functions come with a <code>lemma</code> parameter, which a subwedge domain is responsible for invoking for each theory lemma that is not provable in linear arithmetic. A safe (but inefficient) method for ensuring safety is to call lemma ((Wedge.to_formula in) =&gt; (subwedge.to_formula out)) in <code>of_wedge</code> and lemma ((Wedge.to_formula in1) =&gt; (subwedge.to_formula out)) lemma ((Wedge.to_formula in2) =&gt; (subwedge.to_formula out)) in <code>join</code>.</p></dd></dl><dl><dt class="spec value" id="val-abstract_subwedge"><a href="#val-abstract_subwedge" class="anchor"></a><code><span class="keyword">val</span> abstract_subwedge : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-subwedge">subwedge</a></span> <span>&#45;&gt;</span> <span>?&#8288;exists:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;subterm:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Compute a subwedge that over-approximates a given formula. This is typically faster than using <code>abstract</code> to compute an over-approximating wedge and then</p></dd></dl><dl><dt class="spec value" id="val-is_sat"><a href="#val-is_sat" class="anchor"></a><code><span class="keyword">val</span> is_sat : <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> <span>[ `Sat <span>| `Unsat</span> <span>| `Unknown</span> ]</span></code></dt><dd><p>Check if a formula is satisfiable by computing an over-approximating wedge and checking whether it is feasible. This procedure improves on the naive implementation by returning <code>`Unknown</code> as soon as it finds a disjunct that it can't prove to be infeasible.</p></dd></dl><dl><dt class="spec value" id="val-symbolic_bounds_formula"><a href="#val-symbolic_bounds_formula" class="anchor"></a><code><span class="keyword">val</span> symbolic_bounds_formula : <span>?&#8288;exists:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> <a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> <span>[ <span>`Sat of <span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-term">Syntax.term</a></span> option</span> * <span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-term">Syntax.term</a></span> option</span></span> <span>| `Unsat</span> ]</span></code></dt><dd><p>Compute lower and upper bounds for a symbol that are implied by the given formula (if they exist). The upper and lower bounds may involve only symbols that satisfy the exist predicate, and may involve the functions <code>max</code> and <code>min</code> (binary named symbols). (For example, if <code>x</code> is bounded above by <code>0</code> and <code>y</code>, then the upper bound computed by <code>symbolic_bounds</code> is <code>min(0,y)</code>).</p></dd></dl><dl><dt class="spec value" id="val-symbolic_bounds_formula_list"><a href="#val-symbolic_bounds_formula_list" class="anchor"></a><code><span class="keyword">val</span> symbolic_bounds_formula_list : <span>?&#8288;exists:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> <a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> <span>[ <span>`Sat of <span><span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-term">Syntax.term</a></span> list</span> list</span> * <span><span><span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-term">Syntax.term</a></span> list</span> list</span></span> <span>| `Unsat</span> ]</span></code></dt><dd><p>As <code>symbolic_bounds_formula</code>, execept the lower bound is represented as a min of maxes, and the upper bound is represented as a max of mins.</p></dd></dl><dl><dt class="spec value" id="val-coordinate_system"><a href="#val-coordinate_system" class="anchor"></a><code><span class="keyword">val</span> coordinate_system : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../CoordinateSystem/index.html#type-t">CoordinateSystem.t</a></span></code></dt><dt class="spec value" id="val-polyhedron"><a href="#val-polyhedron" class="anchor"></a><code><span class="keyword">val</span> polyhedron : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span>[ `Eq <span>| `Geq</span> ]</span> * <a href="../Linear/QQVector/index.html#type-t">Linear.QQVector.t</a>)</span> list</span></code></dt><dt class="spec value" id="val-vanishing_ideal"><a href="#val-vanishing_ideal" class="anchor"></a><code><span class="keyword">val</span> vanishing_ideal : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../Polynomial/QQXs/index.html#type-t">Polynomial.QQXs.t</a> list</span></code></dt><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-equational_saturation"><a href="#val-equational_saturation" class="anchor"></a><code><span class="keyword">val</span> equational_saturation : <span>?&#8288;lemma:<span>(<span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Polynomial/Rewrite/index.html#type-t">Polynomial.Rewrite.t</a></code></dt><dt class="spec value" id="val-strengthen"><a href="#val-strengthen" class="anchor"></a><code><span class="keyword">val</span> strengthen : <span>?&#8288;lemma:<span>(<span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val</span> reduce : <span>lemma:<span>(<span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Simplify the constraint represenation of the given wedge. The resulting wedge is equivalent the input, modulo LIRA + the lemmas passed to the lemma procedure.</p></dd></dl><dl><dt class="spec value" id="val-cover"><a href="#val-cover" class="anchor"></a><code><span class="keyword">val</span> cover : <span>?&#8288;subterm:<span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-context">Syntax.context</a></span> <span>&#45;&gt;</span> <span>(<a href="../Syntax/index.html#type-symbol">Syntax.symbol</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Syntax/index.html#type-formula">Syntax.formula</a></span></code></dt><dd><p>Overapproximate existential quantifier elimination.</p></dd></dl></div></body></html>